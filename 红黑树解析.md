# 红黑树（RBTree）

- 红黑树（Red-Black Tree）是一种具有以下性质的平衡二叉树：

  - 对BST的**插入和删除操作时会维持树的平衡**，即保证树的高度在[logN,logN+1]（理论上，极端的情况下可以出现RBT的高度达到2*logN，但实际上很难遇到）。
  - 它保证在最坏情况下，**查找、插入、删除操作的时间复杂度为O(logN)**。
  - 红黑树放弃了完美平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证**每次插入删除最多只需要三次旋转就能达到平衡**，实现起来也更为简单。
  - 从某种意义上来说，**红黑树和2-3树是一种等同**。

- 应用：

  - Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等。
  - 各种语言的函数库，如 Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。
  - Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。

- 定义：

  - **任何一个节点都有颜色，黑色或者红色**。
  - **根节点是黑色的**。
  - **父子节点之间不能出现两个连续的红节点**。
  - **根节点向下遍历到任何一个叶子节点，所经过的黑节点个数必须相等**。
  - **空节点被认为是黑色的**。

  ```java
  class Node<T> {
      public T value;
      public Node<T> parent;
      public boolean isRed;
      public Node<T> left;
      public Node<T> right;
  }
  ```

## 旋转

- 旋转操作（Rotate）的目的是使节点颜色符合定义，让RBTree的高度达到平衡。
- Rotate分为 left-rotate（左旋）和 right-rotate（右旋）。区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。

## 查找

RBTree的查找操作和BST的查找操作是一样的。请参考BST的查找操作代码。

## 插入

- RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称**插入修复**），使得它符合RBTree的定义。

- 前提：假设<新插入的节点>是红色的（如果是黑色则会违反定义4），如果遇到<父节点>的颜色为黑色则修复操作结束。也就是说，**只有在父节点为红色节点的时候需要修复**。

- 插入修复（前提insert节点的父节点是红色）：

  

  <img src="http://q9bww7gmb.bkt.clouddn.com/uPic/数据结构_红黑树插入case1.gif" alt="算法_红黑树插入case1" style="zoom:50%;" />

  

  <img src="http://q9bww7gmb.bkt.clouddn.com/uPic/算法_红黑树插入case2.gif" alt="算法_红黑树插入case2" style="zoom:50%;" />

  

  <img src="http://q9bww7gmb.bkt.clouddn.com/uPic/算法_红黑树插入case3.gif" alt="算法_红黑树插入case3" style="zoom:50%;" />

- 总结：

  - 插入后的修复操作是一个**向root节点回溯**的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。
  - 向上回溯的原因是：**由于case1操作会将<u>父节点</u>、<u>叔叔节点</u>和<u>祖父节点</u>进行换色，有可能会导致<u>祖父节点</u>不平衡（违反规则3），故需要对以<u>祖父节点</u>为起点进行调节（向上回溯）**。
  - <u>祖父节点</u>调节后，如果还是遇到它的祖父颜色问题，则操作就会继续向上回溯，直到root节点为止，根据定义**root节点永远是黑色的**。
  - 在向上回溯的过程中，针对插入的三种情况进行调节。直到牵涉的节点都符合了红黑树的定义，则修复操作结束。

## 删除

- 删除（从现象分析可分为7种情况）：

  |      |      |       |                                                              |
  | ---- | :--- | :---- | ------------------------------------------------------------ |
  | A    |      |       | 1⃣️ <待删除的节点>**有两个子节点：则使用<后继节点>替代<待删除的节点>，从而转换为条件B、C** |
  | B    |      |       | 2⃣️ <待删除的节点>**只有一个子节点：则该节点必为黑色（因为红色节点不可能只有一个节点，否则违反规则4），而其<子节点>必为红色，删除后需要修复**。 |
  | C    |      |       | <待删除的节点>为**叶子结点**，删除后需要修复（此时又分以下四种情况） |
  |      | C_1  |       | 3⃣️ **<待删除的节点>颜色为红色，不需要修复**。                  |
  |      | C_2  |       | **<待删除的节点>颜色为黑色**（思路：**从<兄弟节点>借调黑色节点使树保持局部的平衡**，所以此处要视<兄弟节点>情况分条修复） |
  |      |      | C_2_1 | 4⃣️ **<兄弟节点>为红色**（通过一次旋转，转变为黑色的<兄弟节点>，从而转换为C_2_2、C_2_3、C_2_4） |
  |      |      | C_2_2 | 5⃣️ **<兄弟节点>为黑色，且<侄子节点>都为黑色**（<u>修复操作</u>：将<兄弟节点>变为红色，并向上回溯） |
  |      |      | C_2_3 | 6⃣️ **<兄弟节点>为黑色，且<侄子节点>为”左红右黑“**（此时状态为中间态。<u>修复操作</u>：通过一次旋转，转为C_2_4） |
  |      |      | C_2_4 | 7⃣️ **<兄弟节点>为黑色，且<右侄子节点>为红色**（此时为真正的借调操作，不需要关心<左侄子节点>。<u>修复操作</u>：通过一次旋转，完成所有修复） |

- 删除修复（前提delete节点是黑色）：

  <img src="http://q9bww7gmb.bkt.clouddn.com/uPic/算法_红黑树删除case1.gif" alt="算法_红黑树删除case1" style="zoom:50%;" />

  

  <img src="http://q9bww7gmb.bkt.clouddn.com/uPic/算法_红黑树删除case2.gif" alt="算法_红黑树删除case2" style="zoom:50%;" />

  

  <img src="http://q9bww7gmb.bkt.clouddn.com/uPic/算法_红黑树删除case3.gif" alt="算法_红黑树删除case3" style="zoom:50%;" />

  

  <img src="http://q9bww7gmb.bkt.clouddn.com/uPic/算法_红黑树删除case4.gif" alt="算法_红黑树删除case4" style="zoom:50%;" />

- 总结：
  - 红黑树的删除是最复杂的操作，复杂的地方就在于**当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义**。
  - 由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。
  - 对于兄弟节点是黑色节点的可以分成三种情况来处理：
    - 当兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。
    - 当兄弟节点的子节点为“左红右黑”，可以先将前面的情况通过选择转换为后一种情况。
    - 在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。
  - 红黑树的删除操作是遇到删除的节点为红色，或追溯到root节点，这时修复操作完毕。
